\hypertarget{group__pka__driver}{}\section{Pka\+\_\+driver}
\label{group__pka__driver}\index{Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{group__pka__driver_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{N\+U\+LL}~((\hyperlink{usb__devapi_8h_afabf60e7f57651d6d595a02c75f07cd0}{void}$\ast$)0)
\item 
\#define \hyperlink{group__pka__driver_ga4cb93e92891ad7120992f05616e0a77f}{P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+C\+U\+R\+V\+E\+\_\+\+S\+I\+Z\+E\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD}~12
\item 
\#define \hyperlink{group__pka__driver_ga38ce8bc8a86da72caa13bc9476b9fc41}{P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+L\+E\+N\+\_\+\+I\+N\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD}~\hyperlink{group__pka__driver_ga4cb93e92891ad7120992f05616e0a77f}{P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+C\+U\+R\+V\+E\+\_\+\+S\+I\+Z\+E\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD}
\item 
\#define \hyperlink{group__pka__driver_ga587496a1c16227ec2861c0f5d8f786e9}{P\+K\+A\+\_\+\+R\+A\+M\+\_\+\+S\+I\+ZE}~2000
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{usb__devapi_8h_afabf60e7f57651d6d595a02c75f07cd0}{void} \hyperlink{group__pka__driver_gaed47ea15b15663675629b0e0388afede}{P\+K\+A\+Enable\+Int} (\hyperlink{usb__devapi_8h_afabf60e7f57651d6d595a02c75f07cd0}{void})
\item 
\hyperlink{usb__devapi_8h_afabf60e7f57651d6d595a02c75f07cd0}{void} \hyperlink{group__pka__driver_ga332c572585f555dc982817a355284f70}{P\+K\+A\+Disable\+Int} (\hyperlink{usb__devapi_8h_afabf60e7f57651d6d595a02c75f07cd0}{void})
\item 
\hyperlink{usb__devapi_8h_afabf60e7f57651d6d595a02c75f07cd0}{void} \hyperlink{group__pka__driver_gaac0d2e55a0331401d91eb645e043d333}{P\+K\+A\+Clear\+Int} (\hyperlink{usb__devapi_8h_afabf60e7f57651d6d595a02c75f07cd0}{void})
\item 
\hyperlink{usb__devapi_8h_afabf60e7f57651d6d595a02c75f07cd0}{void} \hyperlink{group__pka__driver_ga8e873132638c12c2ac9fca35a36013d6}{P\+K\+A\+Reg\+Int} (\hyperlink{usb__devapi_8h_afabf60e7f57651d6d595a02c75f07cd0}{void}($\ast$pfn\+Handler)(\hyperlink{usb__devapi_8h_afabf60e7f57651d6d595a02c75f07cd0}{void}))
\item 
\hyperlink{usb__devapi_8h_afabf60e7f57651d6d595a02c75f07cd0}{void} \hyperlink{group__pka__driver_ga2d21625a6c77aee8721066476a68275d}{P\+K\+A\+Un\+Reg\+Int} (\hyperlink{usb__devapi_8h_afabf60e7f57651d6d595a02c75f07cd0}{void})
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_ga82d30b6e54d4e06c2fd871dbefbf90c5}{P\+K\+A\+Get\+Ops\+Status} (\hyperlink{usb__devapi_8h_afabf60e7f57651d6d595a02c75f07cd0}{void})
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_gadcb3179ff4f5d836e35d9b4505220787}{P\+K\+A\+Big\+Num\+Mod\+Start} (\hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+B\+Num, \hyperlink{_p_e___types_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} ui8\+B\+N\+Size, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Modulus, \hyperlink{_p_e___types_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} ui8\+Mod\+Size, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Result\+Vector)
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_ga23ee9b245d913950bdab98fb80e72f16}{P\+K\+A\+Big\+Num\+Mod\+Get\+Result} (\hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Result\+Buf, \hyperlink{_p_e___types_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} ui8\+Size, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} ui32\+Res\+Vector\+Loc)
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_ga6b8827a49b626e7c90608ecbbc59e2b0}{P\+K\+A\+Big\+Num\+Cmp\+Start} (\hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+B\+Num1, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+B\+Num2, \hyperlink{_p_e___types_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} ui8\+Size)
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_ga0b7348fb8033dfcb8a1584dfb064bf3f}{P\+K\+A\+Big\+Num\+Cmp\+Get\+Result} (\hyperlink{usb__devapi_8h_afabf60e7f57651d6d595a02c75f07cd0}{void})
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_ga789ed728264b5f3d5b411ca72615e470}{P\+K\+A\+Big\+Num\+Inv\+Mod\+Start} (\hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+B\+Num, \hyperlink{_p_e___types_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} ui8\+B\+N\+Size, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Modulus, \hyperlink{_p_e___types_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} ui8\+Size, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Result\+Vector)
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_gaeb5b970ba8ccea84761f2b84ffc3408e}{P\+K\+A\+Big\+Num\+Inv\+Mod\+Get\+Result} (\hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Result\+Buf, \hyperlink{_p_e___types_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} ui8\+Size, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} ui32\+Res\+Vector\+Loc)
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_gab72dd0782a8e971133dfc94b267881a1}{P\+K\+A\+Big\+Num\+Multiply\+Start} (\hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Xplicand, \hyperlink{_p_e___types_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} ui8\+Xplicand\+Size, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Xplier, \hyperlink{_p_e___types_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} ui8\+Xplier\+Size, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Result\+Vector)
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_ga4891923a934ab7b9e174fdfd014665c6}{P\+K\+A\+Big\+Num\+Mult\+Get\+Result} (\hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Result\+Buf, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Len, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} ui32\+Res\+Vector\+Loc)
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_ga41ae8dff39418d7499db8555a2a4b592}{P\+K\+A\+Big\+Num\+Add\+Start} (\hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+B\+N1, \hyperlink{_p_e___types_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} ui8\+B\+N1\+Size, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+B\+N2, \hyperlink{_p_e___types_8h_aba7bc1797add20fe3efdf37ced1182c5}{uint8\+\_\+t} ui8\+B\+N2\+Size, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Result\+Vector)
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_ga77cf473c12e2c506e6753dacfd3bf219}{P\+K\+A\+Big\+Num\+Add\+Get\+Result} (\hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Result\+Buf, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Len, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} ui32\+Res\+Vector\+Loc)
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_ga99c8ab12e5a5fcba7f63ad0d2f9a98dd}{P\+K\+A\+E\+C\+C\+Multiply\+Start} (\hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Scalar, \hyperlink{pka_8h_ad8a0d9ffc3dc89cecf35c8fac620a030}{t\+E\+C\+Pt} $\ast$pt\+Ec\+Pt, \hyperlink{ecc__curveinfo_8h_a17a628519ae5ba49f5cf62decade4dcb}{t\+E\+C\+C\+Curve\+Info} $\ast$pt\+Curve, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Result\+Vector)
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_ga8ed171250f4b3a26e1f8268a41503450}{P\+K\+A\+E\+C\+C\+Multiply\+Get\+Result} (\hyperlink{pka_8h_ad8a0d9ffc3dc89cecf35c8fac620a030}{t\+E\+C\+Pt} $\ast$pt\+Out\+Ec\+Pt, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} ui32\+Res\+Vector\+Loc)
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_ga37519c82259a12764cb68cb265bc09c9}{P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Start} (\hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Scalar, \hyperlink{ecc__curveinfo_8h_a17a628519ae5ba49f5cf62decade4dcb}{t\+E\+C\+C\+Curve\+Info} $\ast$pt\+Curve, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Result\+Vector)
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_ga5fe2796e884a65a75bb1732831e0bca9}{P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Get\+Result} (\hyperlink{pka_8h_ad8a0d9ffc3dc89cecf35c8fac620a030}{t\+E\+C\+Pt} $\ast$pt\+Out\+Ec\+Pt, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} ui32\+Res\+Vector\+Loc)
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_gab12f37d870c923e7800d0523c40442a6}{P\+K\+A\+E\+C\+C\+Add\+Start} (\hyperlink{pka_8h_ad8a0d9ffc3dc89cecf35c8fac620a030}{t\+E\+C\+Pt} $\ast$pt\+Ec\+Pt1, \hyperlink{pka_8h_ad8a0d9ffc3dc89cecf35c8fac620a030}{t\+E\+C\+Pt} $\ast$pt\+Ec\+Pt2, \hyperlink{ecc__curveinfo_8h_a17a628519ae5ba49f5cf62decade4dcb}{t\+E\+C\+C\+Curve\+Info} $\ast$pt\+Curve, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} $\ast$pui32\+Result\+Vector)
\item 
\hyperlink{pka_8h_a94af1eb5fa0257508f865b5e40de4ed3}{t\+P\+K\+A\+Status} \hyperlink{group__pka__driver_ga4fe3c47d5600bd8e8b073a19ec96d258}{P\+K\+A\+E\+C\+C\+Add\+Get\+Result} (\hyperlink{pka_8h_ad8a0d9ffc3dc89cecf35c8fac620a030}{t\+E\+C\+Pt} $\ast$pt\+Out\+Ec\+Pt, \hyperlink{_p_e___types_8h_a33594304e786b158f3fb30289278f5af}{uint32\+\_\+t} ui32\+Res\+Vector\+Loc)
\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Macro Definition Documentation}
\index{Pka\+\_\+driver@{Pka\+\_\+driver}!N\+U\+LL@{N\+U\+LL}}
\index{N\+U\+LL@{N\+U\+LL}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{N\+U\+LL}{NULL}}]{\setlength{\rightskip}{0pt plus 5cm}\#define N\+U\+LL~(({\bf void}$\ast$)0)}\hypertarget{group__pka__driver_ga070d2ce7b6bb7e5c05602aa8c308d0c4}{}\label{group__pka__driver_ga070d2ce7b6bb7e5c05602aa8c308d0c4}


Definition at line 63 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+C\+U\+R\+V\+E\+\_\+\+S\+I\+Z\+E\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD@{P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+C\+U\+R\+V\+E\+\_\+\+S\+I\+Z\+E\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD}}
\index{P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+C\+U\+R\+V\+E\+\_\+\+S\+I\+Z\+E\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD@{P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+C\+U\+R\+V\+E\+\_\+\+S\+I\+Z\+E\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+C\+U\+R\+V\+E\+\_\+\+S\+I\+Z\+E\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD}{PKA_MAX_CURVE_SIZE_32_BIT_WORD}}]{\setlength{\rightskip}{0pt plus 5cm}\#define P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+C\+U\+R\+V\+E\+\_\+\+S\+I\+Z\+E\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD~12}\hypertarget{group__pka__driver_ga4cb93e92891ad7120992f05616e0a77f}{}\label{group__pka__driver_ga4cb93e92891ad7120992f05616e0a77f}


Definition at line 74 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+L\+E\+N\+\_\+\+I\+N\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD@{P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+L\+E\+N\+\_\+\+I\+N\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD}}
\index{P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+L\+E\+N\+\_\+\+I\+N\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD@{P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+L\+E\+N\+\_\+\+I\+N\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+L\+E\+N\+\_\+\+I\+N\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD}{PKA_MAX_LEN_IN_32_BIT_WORD}}]{\setlength{\rightskip}{0pt plus 5cm}\#define P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+L\+E\+N\+\_\+\+I\+N\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD~{\bf P\+K\+A\+\_\+\+M\+A\+X\+\_\+\+C\+U\+R\+V\+E\+\_\+\+S\+I\+Z\+E\+\_\+32\+\_\+\+B\+I\+T\+\_\+\+W\+O\+RD}}\hypertarget{group__pka__driver_ga38ce8bc8a86da72caa13bc9476b9fc41}{}\label{group__pka__driver_ga38ce8bc8a86da72caa13bc9476b9fc41}


Definition at line 83 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+\_\+\+R\+A\+M\+\_\+\+S\+I\+ZE@{P\+K\+A\+\_\+\+R\+A\+M\+\_\+\+S\+I\+ZE}}
\index{P\+K\+A\+\_\+\+R\+A\+M\+\_\+\+S\+I\+ZE@{P\+K\+A\+\_\+\+R\+A\+M\+\_\+\+S\+I\+ZE}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+\_\+\+R\+A\+M\+\_\+\+S\+I\+ZE}{PKA_RAM_SIZE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define P\+K\+A\+\_\+\+R\+A\+M\+\_\+\+S\+I\+ZE~2000}\hypertarget{group__pka__driver_ga587496a1c16227ec2861c0f5d8f786e9}{}\label{group__pka__driver_ga587496a1c16227ec2861c0f5d8f786e9}


Definition at line 91 of file pka.\+c.



\subsection{Function Documentation}
\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Big\+Num\+Add\+Get\+Result@{P\+K\+A\+Big\+Num\+Add\+Get\+Result}}
\index{P\+K\+A\+Big\+Num\+Add\+Get\+Result@{P\+K\+A\+Big\+Num\+Add\+Get\+Result}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Big\+Num\+Add\+Get\+Result(uint32\+\_\+t $\ast$pui32\+Result\+Buf, uint32\+\_\+t $\ast$pui32\+Len, uint32\+\_\+t ui32\+Res\+Vector\+Loc)}{PKABigNumAddGetResult(uint32_t *pui32ResultBuf, uint32_t *pui32Len, uint32_t ui32ResVectorLoc)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+Big\+Num\+Add\+Get\+Result (
\begin{DoxyParamCaption}
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Result\+Buf, }
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Len, }
\item[{{\bf uint32\+\_\+t}}]{ui32\+Res\+Vector\+Loc}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga77cf473c12e2c506e6753dacfd3bf219}{}\label{group__pka__driver_ga77cf473c12e2c506e6753dacfd3bf219}
Gets the result of the addition operation on two big number.


\begin{DoxyParams}{Parameters}
{\em pui32\+Result\+Buf} & is the pointer to buffer where the result needs to be stored. \\
\hline
{\em pui32\+Len} & is the address of the variable containing the length of the buffer. After the operation the actual length of the resultant is stored at this address. \\
\hline
{\em ui32\+Res\+Vector\+Loc} & is the address of the result location which was provided by the start function \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_ga41ae8dff39418d7499db8555a2a4b592}{P\+K\+A\+Big\+Num\+Add\+Start()}.
\end{DoxySeeAlso}
This function gets the result of the addition operation on two big numbers, previously started using the function \begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_ga41ae8dff39418d7499db8555a2a4b592}{P\+K\+A\+Big\+Num\+Add\+Start()}.
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if the operation is successful.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy performing the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+0} if the result is all zeroes.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+U\+RE} if the operation is not successful.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+B\+U\+F\+\_\+\+U\+N\+D\+E\+R\+F\+L\+OW} if the length of the provided buffer is less then the length of the result. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 1095 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Big\+Num\+Add\+Start@{P\+K\+A\+Big\+Num\+Add\+Start}}
\index{P\+K\+A\+Big\+Num\+Add\+Start@{P\+K\+A\+Big\+Num\+Add\+Start}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Big\+Num\+Add\+Start(uint32\+\_\+t $\ast$pui32\+B\+N1, uint8\+\_\+t ui8\+B\+N1\+Size, uint32\+\_\+t $\ast$pui32\+B\+N2, uint8\+\_\+t ui8\+B\+N2\+Size, uint32\+\_\+t $\ast$pui32\+Result\+Vector)}{PKABigNumAddStart(uint32_t *pui32BN1, uint8_t ui8BN1Size, uint32_t *pui32BN2, uint8_t ui8BN2Size, uint32_t *pui32ResultVector)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+Big\+Num\+Add\+Start (
\begin{DoxyParamCaption}
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+B\+N1, }
\item[{{\bf uint8\+\_\+t}}]{ui8\+B\+N1\+Size, }
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+B\+N2, }
\item[{{\bf uint8\+\_\+t}}]{ui8\+B\+N2\+Size, }
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Result\+Vector}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga41ae8dff39418d7499db8555a2a4b592}{}\label{group__pka__driver_ga41ae8dff39418d7499db8555a2a4b592}
Starts the addition of two big number.


\begin{DoxyParams}{Parameters}
{\em pui32\+B\+N1} & is the pointer to the buffer containing the first big mumber. \\
\hline
{\em ui8\+B\+N1\+Size} & is the size of the first big number in 32-\/bit word. \\
\hline
{\em pui32\+B\+N2} & is the pointer to the buffer containing the second big number. \\
\hline
{\em ui8\+B\+N2\+Size} & is the size of the second big number in 32-\/bit word. \\
\hline
{\em pui32\+Result\+Vector} & is the pointer to the result vector location which will be set by this function.\\
\hline
\end{DoxyParams}
This function starts the addition of the two big numbers.

\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if successful in starting the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy doing some other operation. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 983 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Big\+Num\+Cmp\+Get\+Result@{P\+K\+A\+Big\+Num\+Cmp\+Get\+Result}}
\index{P\+K\+A\+Big\+Num\+Cmp\+Get\+Result@{P\+K\+A\+Big\+Num\+Cmp\+Get\+Result}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Big\+Num\+Cmp\+Get\+Result(void)}{PKABigNumCmpGetResult(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+Big\+Num\+Cmp\+Get\+Result (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga0b7348fb8033dfcb8a1584dfb064bf3f}{}\label{group__pka__driver_ga0b7348fb8033dfcb8a1584dfb064bf3f}
Gets the result of the comparison operation of two big numbers.

This function provides the results of the comparison of two big numbers which was started using the \begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_ga6b8827a49b626e7c90608ecbbc59e2b0}{P\+K\+A\+Big\+Num\+Cmp\+Start()}.
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG} if the operation is in progress.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if the two big numbers are equal.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+A\+\_\+\+G\+R\+\_\+B} if the first number is greater than the second.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+A\+\_\+\+L\+T\+\_\+B} if the first number is less than the second. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 527 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Big\+Num\+Cmp\+Start@{P\+K\+A\+Big\+Num\+Cmp\+Start}}
\index{P\+K\+A\+Big\+Num\+Cmp\+Start@{P\+K\+A\+Big\+Num\+Cmp\+Start}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Big\+Num\+Cmp\+Start(uint32\+\_\+t $\ast$pui32\+B\+Num1, uint32\+\_\+t $\ast$pui32\+B\+Num2, uint8\+\_\+t ui8\+Size)}{PKABigNumCmpStart(uint32_t *pui32BNum1, uint32_t *pui32BNum2, uint8_t ui8Size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+Big\+Num\+Cmp\+Start (
\begin{DoxyParamCaption}
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+B\+Num1, }
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+B\+Num2, }
\item[{{\bf uint8\+\_\+t}}]{ui8\+Size}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga6b8827a49b626e7c90608ecbbc59e2b0}{}\label{group__pka__driver_ga6b8827a49b626e7c90608ecbbc59e2b0}
Starts the comparison of two big numbers.


\begin{DoxyParams}{Parameters}
{\em pui32\+B\+Num1} & is the pointer to the first big number. \\
\hline
{\em pui32\+B\+Num2} & is the pointer to the second big number. \\
\hline
{\em ui8\+Size} & is the size of the big number in 32 bit size word.\\
\hline
\end{DoxyParams}
This function starts the comparison of two big numbers pointed by {\itshape pui32\+B\+Num1} and {\itshape pui32\+B\+Num2}. Note this function expects the size of the two big numbers equal.

\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if successful in starting the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy doing some other operation. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 444 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Big\+Num\+Inv\+Mod\+Get\+Result@{P\+K\+A\+Big\+Num\+Inv\+Mod\+Get\+Result}}
\index{P\+K\+A\+Big\+Num\+Inv\+Mod\+Get\+Result@{P\+K\+A\+Big\+Num\+Inv\+Mod\+Get\+Result}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Big\+Num\+Inv\+Mod\+Get\+Result(uint32\+\_\+t $\ast$pui32\+Result\+Buf, uint8\+\_\+t ui8\+Size, uint32\+\_\+t ui32\+Res\+Vector\+Loc)}{PKABigNumInvModGetResult(uint32_t *pui32ResultBuf, uint8_t ui8Size, uint32_t ui32ResVectorLoc)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+Big\+Num\+Inv\+Mod\+Get\+Result (
\begin{DoxyParamCaption}
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Result\+Buf, }
\item[{{\bf uint8\+\_\+t}}]{ui8\+Size, }
\item[{{\bf uint32\+\_\+t}}]{ui32\+Res\+Vector\+Loc}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_gaeb5b970ba8ccea84761f2b84ffc3408e}{}\label{group__pka__driver_gaeb5b970ba8ccea84761f2b84ffc3408e}
Gets the result of the big number inverse modulo operation.


\begin{DoxyParams}{Parameters}
{\em pui32\+Result\+Buf} & is the pointer to buffer where the result needs to be stored. \\
\hline
{\em ui8\+Size} & is the size of the provided buffer in 32 bit ui8\+Size word. \\
\hline
{\em ui32\+Res\+Vector\+Loc} & is the address of the result location which was provided by the start function \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_ga789ed728264b5f3d5b411ca72615e470}{P\+K\+A\+Big\+Num\+Inv\+Mod\+Start()}.
\end{DoxySeeAlso}
This function gets the result of the big number inverse modulo operation previously started using the function \begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_ga789ed728264b5f3d5b411ca72615e470}{P\+K\+A\+Big\+Num\+Inv\+Mod\+Start()}.
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if the operation is successful.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy performing the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+0} if the result is all zeroes.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+B\+U\+F\+\_\+\+U\+N\+D\+E\+R\+F\+L\+OW} if the length of the provided buffer is less then the result. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 697 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Big\+Num\+Inv\+Mod\+Start@{P\+K\+A\+Big\+Num\+Inv\+Mod\+Start}}
\index{P\+K\+A\+Big\+Num\+Inv\+Mod\+Start@{P\+K\+A\+Big\+Num\+Inv\+Mod\+Start}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Big\+Num\+Inv\+Mod\+Start(uint32\+\_\+t $\ast$pui32\+B\+Num, uint8\+\_\+t ui8\+B\+N\+Size, uint32\+\_\+t $\ast$pui32\+Modulus, uint8\+\_\+t ui8\+Size, uint32\+\_\+t $\ast$pui32\+Result\+Vector)}{PKABigNumInvModStart(uint32_t *pui32BNum, uint8_t ui8BNSize, uint32_t *pui32Modulus, uint8_t ui8Size, uint32_t *pui32ResultVector)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+Big\+Num\+Inv\+Mod\+Start (
\begin{DoxyParamCaption}
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+B\+Num, }
\item[{{\bf uint8\+\_\+t}}]{ui8\+B\+N\+Size, }
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Modulus, }
\item[{{\bf uint8\+\_\+t}}]{ui8\+Size, }
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Result\+Vector}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga789ed728264b5f3d5b411ca72615e470}{}\label{group__pka__driver_ga789ed728264b5f3d5b411ca72615e470}
Starts the big number inverse modulo operation.


\begin{DoxyParams}{Parameters}
{\em pui32\+B\+Num} & is the pointer to the buffer containing the big number (dividend). \\
\hline
{\em ui8\+B\+N\+Size} & is the size of the {\itshape pui32\+B\+Num} in 32 bit word. \\
\hline
{\em pui32\+Modulus} & is the pointer to the buffer containing the divisor. \\
\hline
{\em ui8\+Size} & is the size of the divisor in 32 bit word. \\
\hline
{\em pui32\+Result\+Vector} & is the pointer to the result vector location which will be set by this function.\\
\hline
\end{DoxyParams}
This function starts the the inverse modulo operation on {\itshape pui32\+B\+Num} using the divisor {\itshape pui32\+Modulus}.

\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if successful in starting the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy doing some other operation. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 587 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Big\+Num\+Mod\+Get\+Result@{P\+K\+A\+Big\+Num\+Mod\+Get\+Result}}
\index{P\+K\+A\+Big\+Num\+Mod\+Get\+Result@{P\+K\+A\+Big\+Num\+Mod\+Get\+Result}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Big\+Num\+Mod\+Get\+Result(uint32\+\_\+t $\ast$pui32\+Result\+Buf, uint8\+\_\+t ui8\+Size, uint32\+\_\+t ui32\+Res\+Vector\+Loc)}{PKABigNumModGetResult(uint32_t *pui32ResultBuf, uint8_t ui8Size, uint32_t ui32ResVectorLoc)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+Big\+Num\+Mod\+Get\+Result (
\begin{DoxyParamCaption}
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Result\+Buf, }
\item[{{\bf uint8\+\_\+t}}]{ui8\+Size, }
\item[{{\bf uint32\+\_\+t}}]{ui32\+Res\+Vector\+Loc}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga23ee9b245d913950bdab98fb80e72f16}{}\label{group__pka__driver_ga23ee9b245d913950bdab98fb80e72f16}
Gets the result of the big number modulus operation.


\begin{DoxyParams}{Parameters}
{\em pui32\+Result\+Buf} & is the pointer to buffer where the result needs to be stored. \\
\hline
{\em ui8\+Size} & is the size of the provided buffer in 32 bit size word. \\
\hline
{\em ui32\+Res\+Vector\+Loc} & is the address of the result location which was provided by the start function \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_gadcb3179ff4f5d836e35d9b4505220787}{P\+K\+A\+Big\+Num\+Mod\+Start()}.
\end{DoxySeeAlso}
This function gets the result of the big number modulus operation which was previously started using the function \begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_gadcb3179ff4f5d836e35d9b4505220787}{P\+K\+A\+Big\+Num\+Mod\+Start()}.
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if successful.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy doing the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+0} if the result is all zeroes.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+B\+U\+F\+\_\+\+U\+N\+D\+E\+R\+F\+L\+OW}, if the {\itshape ui8\+Size} is less than the length of the result. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 364 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Big\+Num\+Mod\+Start@{P\+K\+A\+Big\+Num\+Mod\+Start}}
\index{P\+K\+A\+Big\+Num\+Mod\+Start@{P\+K\+A\+Big\+Num\+Mod\+Start}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Big\+Num\+Mod\+Start(uint32\+\_\+t $\ast$pui32\+B\+Num, uint8\+\_\+t ui8\+B\+N\+Size, uint32\+\_\+t $\ast$pui32\+Modulus, uint8\+\_\+t ui8\+Mod\+Size, uint32\+\_\+t $\ast$pui32\+Result\+Vector)}{PKABigNumModStart(uint32_t *pui32BNum, uint8_t ui8BNSize, uint32_t *pui32Modulus, uint8_t ui8ModSize, uint32_t *pui32ResultVector)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+Big\+Num\+Mod\+Start (
\begin{DoxyParamCaption}
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+B\+Num, }
\item[{{\bf uint8\+\_\+t}}]{ui8\+B\+N\+Size, }
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Modulus, }
\item[{{\bf uint8\+\_\+t}}]{ui8\+Mod\+Size, }
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Result\+Vector}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_gadcb3179ff4f5d836e35d9b4505220787}{}\label{group__pka__driver_gadcb3179ff4f5d836e35d9b4505220787}
Starts the big number modulus operation.


\begin{DoxyParams}{Parameters}
{\em pui32\+B\+Num} & is the pointer to the big number on which modulo operation needs to be carried out. \\
\hline
{\em ui8\+B\+N\+Size} & is the size of the big number \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
pui32\+B\+Num in 32-\/bit \hyperlink{_p_e___types_8h_abad51e07ab6d26bec9f1f786c8d65bcd}{word}. 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em pui32\+Modulus} & is the pointer to the divisor. \\
\hline
{\em ui8\+Mod\+Size} & is the size of the divisor \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
pui32\+Modulus. 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em pui32\+Result\+Vector} & is the pointer to the result vector location which will be set by this function.\\
\hline
\end{DoxyParams}
This function starts the modulo operation on the big num \begin{DoxySeeAlso}{See also}
pui32\+B\+Num using the divisor 

pui32\+Modulus. The P\+KA R\+AM location where the result will be available is stored in 

pui32\+Result\+Vector.
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if successful in starting the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy doing some other operation. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 245 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Big\+Num\+Mult\+Get\+Result@{P\+K\+A\+Big\+Num\+Mult\+Get\+Result}}
\index{P\+K\+A\+Big\+Num\+Mult\+Get\+Result@{P\+K\+A\+Big\+Num\+Mult\+Get\+Result}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Big\+Num\+Mult\+Get\+Result(uint32\+\_\+t $\ast$pui32\+Result\+Buf, uint32\+\_\+t $\ast$pui32\+Len, uint32\+\_\+t ui32\+Res\+Vector\+Loc)}{PKABigNumMultGetResult(uint32_t *pui32ResultBuf, uint32_t *pui32Len, uint32_t ui32ResVectorLoc)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+Big\+Num\+Mult\+Get\+Result (
\begin{DoxyParamCaption}
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Result\+Buf, }
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Len, }
\item[{{\bf uint32\+\_\+t}}]{ui32\+Res\+Vector\+Loc}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga4891923a934ab7b9e174fdfd014665c6}{}\label{group__pka__driver_ga4891923a934ab7b9e174fdfd014665c6}
Gets the results of the big number multiplication.


\begin{DoxyParams}{Parameters}
{\em pui32\+Result\+Buf} & is the pointer to buffer where the result needs to be stored. \\
\hline
{\em pui32\+Len} & is the address of the variable containing the length of the buffer. After the operation, the actual length of the resultant is stored at this address. \\
\hline
{\em ui32\+Res\+Vector\+Loc} & is the address of the result location which was provided by the start function \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_gab72dd0782a8e971133dfc94b267881a1}{P\+K\+A\+Big\+Num\+Multiply\+Start()}.
\end{DoxySeeAlso}
This function gets the result of the multiplication of two big numbers operation previously started using the function \begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_gab72dd0782a8e971133dfc94b267881a1}{P\+K\+A\+Big\+Num\+Multiply\+Start()}.
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if the operation is successful.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy performing the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+0} if the result is all zeroes.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+U\+RE} if the operation is not successful.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+B\+U\+F\+\_\+\+U\+N\+D\+E\+R\+F\+L\+OW} if the length of the provided buffer is less then the length of the result. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 894 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Big\+Num\+Multiply\+Start@{P\+K\+A\+Big\+Num\+Multiply\+Start}}
\index{P\+K\+A\+Big\+Num\+Multiply\+Start@{P\+K\+A\+Big\+Num\+Multiply\+Start}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Big\+Num\+Multiply\+Start(uint32\+\_\+t $\ast$pui32\+Xplicand, uint8\+\_\+t ui8\+Xplicand\+Size, uint32\+\_\+t $\ast$pui32\+Xplier, uint8\+\_\+t ui8\+Xplier\+Size, uint32\+\_\+t $\ast$pui32\+Result\+Vector)}{PKABigNumMultiplyStart(uint32_t *pui32Xplicand, uint8_t ui8XplicandSize, uint32_t *pui32Xplier, uint8_t ui8XplierSize, uint32_t *pui32ResultVector)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+Big\+Num\+Multiply\+Start (
\begin{DoxyParamCaption}
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Xplicand, }
\item[{{\bf uint8\+\_\+t}}]{ui8\+Xplicand\+Size, }
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Xplier, }
\item[{{\bf uint8\+\_\+t}}]{ui8\+Xplier\+Size, }
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Result\+Vector}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_gab72dd0782a8e971133dfc94b267881a1}{}\label{group__pka__driver_gab72dd0782a8e971133dfc94b267881a1}
Starts the big number multiplication.


\begin{DoxyParams}{Parameters}
{\em pui32\+Xplicand} & is the pointer to the buffer containing the big number multiplicand. \\
\hline
{\em ui8\+Xplicand\+Size} & is the size of the multiplicand in 32-\/bit word. \\
\hline
{\em pui32\+Xplier} & is the pointer to the buffer containing the big number multiplier. \\
\hline
{\em ui8\+Xplier\+Size} & is the size of the multiplier in 32-\/bit word. \\
\hline
{\em pui32\+Result\+Vector} & is the pointer to the result vector location which will be set by this function.\\
\hline
\end{DoxyParams}
This function starts the multiplication of the two big numbers.

\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if successful in starting the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy doing some other operation. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 779 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Clear\+Int@{P\+K\+A\+Clear\+Int}}
\index{P\+K\+A\+Clear\+Int@{P\+K\+A\+Clear\+Int}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Clear\+Int(void)}{PKAClearInt(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} P\+K\+A\+Clear\+Int (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_gaac0d2e55a0331401d91eb645e043d333}{}\label{group__pka__driver_gaac0d2e55a0331401d91eb645e043d333}
Clears the P\+KA interrupt.

This function unpends P\+KA interrupt. This will cause any previously generated P\+KA interrupts that have not been handled yet to be discarded.

\begin{DoxyReturn}{Returns}
None. 
\end{DoxyReturn}


Definition at line 141 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Disable\+Int@{P\+K\+A\+Disable\+Int}}
\index{P\+K\+A\+Disable\+Int@{P\+K\+A\+Disable\+Int}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Disable\+Int(void)}{PKADisableInt(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} P\+K\+A\+Disable\+Int (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga332c572585f555dc982817a355284f70}{}\label{group__pka__driver_ga332c572585f555dc982817a355284f70}
Disables the P\+KA interrupt.

This function disables the P\+KA interrupt.

\begin{DoxyReturn}{Returns}
None. 
\end{DoxyReturn}


Definition at line 122 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+E\+C\+C\+Add\+Get\+Result@{P\+K\+A\+E\+C\+C\+Add\+Get\+Result}}
\index{P\+K\+A\+E\+C\+C\+Add\+Get\+Result@{P\+K\+A\+E\+C\+C\+Add\+Get\+Result}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+E\+C\+C\+Add\+Get\+Result(t\+E\+C\+Pt $\ast$pt\+Out\+Ec\+Pt, uint32\+\_\+t ui32\+Res\+Vector\+Loc)}{PKAECCAddGetResult(tECPt *ptOutEcPt, uint32_t ui32ResVectorLoc)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+E\+C\+C\+Add\+Get\+Result (
\begin{DoxyParamCaption}
\item[{{\bf t\+E\+C\+Pt} $\ast$}]{pt\+Out\+Ec\+Pt, }
\item[{{\bf uint32\+\_\+t}}]{ui32\+Res\+Vector\+Loc}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga4fe3c47d5600bd8e8b073a19ec96d258}{}\label{group__pka__driver_ga4fe3c47d5600bd8e8b073a19ec96d258}
Gets the result of the E\+CC Addition


\begin{DoxyParams}{Parameters}
{\em pt\+Out\+Ec\+Pt} & is the pointer to the structure where the resultant point will be stored. The callee is responsible to allocate memory, for the ec point structure including the memory for x and y co-\/ordinate values. \\
\hline
{\em ui32\+Res\+Vector\+Loc} & is the address of the result location which was provided by the function \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_gab12f37d870c923e7800d0523c40442a6}{P\+K\+A\+E\+C\+C\+Add\+Start()}.
\end{DoxySeeAlso}
This function gets the result of ecc point addition operation on the on the two given ec points, previously started using the function \begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_gab12f37d870c923e7800d0523c40442a6}{P\+K\+A\+E\+C\+C\+Add\+Start()}.
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if the operation is successful.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy performing the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+0} if the result is all zeroes.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+U\+RE} if the operation is not successful. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 1909 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+E\+C\+C\+Add\+Start@{P\+K\+A\+E\+C\+C\+Add\+Start}}
\index{P\+K\+A\+E\+C\+C\+Add\+Start@{P\+K\+A\+E\+C\+C\+Add\+Start}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+E\+C\+C\+Add\+Start(t\+E\+C\+Pt $\ast$pt\+Ec\+Pt1, t\+E\+C\+Pt $\ast$pt\+Ec\+Pt2, t\+E\+C\+C\+Curve\+Info $\ast$pt\+Curve, uint32\+\_\+t $\ast$pui32\+Result\+Vector)}{PKAECCAddStart(tECPt *ptEcPt1, tECPt *ptEcPt2, tECCCurveInfo *ptCurve, uint32_t *pui32ResultVector)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+E\+C\+C\+Add\+Start (
\begin{DoxyParamCaption}
\item[{{\bf t\+E\+C\+Pt} $\ast$}]{pt\+Ec\+Pt1, }
\item[{{\bf t\+E\+C\+Pt} $\ast$}]{pt\+Ec\+Pt2, }
\item[{{\bf t\+E\+C\+C\+Curve\+Info} $\ast$}]{pt\+Curve, }
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Result\+Vector}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_gab12f37d870c923e7800d0523c40442a6}{}\label{group__pka__driver_gab12f37d870c923e7800d0523c40442a6}
Starts the E\+CC Addition.


\begin{DoxyParams}{Parameters}
{\em pt\+Ec\+Pt1} & is the pointer to the structure containing the first ecc point. \\
\hline
{\em pt\+Ec\+Pt2} & is the pointer to the structure containing the second ecc point. \\
\hline
{\em pt\+Curve} & is the pointer to the structure containing the curve info. \\
\hline
{\em pui32\+Result\+Vector} & is the pointer to the result vector location which will be set by this function.\\
\hline
\end{DoxyParams}
This function starts the ecc point addition operation on the two given ec points and generates the resultant ecc point.

\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if successful in starting the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy doing some other operation. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 1731 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Get\+Result@{P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Get\+Result}}
\index{P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Get\+Result@{P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Get\+Result}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Get\+Result(t\+E\+C\+Pt $\ast$pt\+Out\+Ec\+Pt, uint32\+\_\+t ui32\+Res\+Vector\+Loc)}{PKAECCMultGenPtGetResult(tECPt *ptOutEcPt, uint32_t ui32ResVectorLoc)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Get\+Result (
\begin{DoxyParamCaption}
\item[{{\bf t\+E\+C\+Pt} $\ast$}]{pt\+Out\+Ec\+Pt, }
\item[{{\bf uint32\+\_\+t}}]{ui32\+Res\+Vector\+Loc}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga5fe2796e884a65a75bb1732831e0bca9}{}\label{group__pka__driver_ga5fe2796e884a65a75bb1732831e0bca9}
Gets the result of E\+CC Multiplication with Generator point.


\begin{DoxyParams}{Parameters}
{\em pt\+Out\+Ec\+Pt} & is the pointer to the structure where the resultant EC point will be stored. The callee is responsible to allocate the space for the ec point structure and the x and y co-\/ordinate as well. \\
\hline
{\em ui32\+Res\+Vector\+Loc} & is the address of the result location which was provided by the start function \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_ga37519c82259a12764cb68cb265bc09c9}{P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Start()}.
\end{DoxySeeAlso}
This function gets the result of ecc point multiplication operation on the scalar point and the known generator point on the curve, previously started using the function \begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_ga37519c82259a12764cb68cb265bc09c9}{P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Start()}.
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if the operation is successful.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy performing the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+0} if the result is all zeroes.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+U\+RE} if the operation is not successful. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 1633 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Start@{P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Start}}
\index{P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Start@{P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Start}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Start(uint32\+\_\+t $\ast$pui32\+Scalar, t\+E\+C\+C\+Curve\+Info $\ast$pt\+Curve, uint32\+\_\+t $\ast$pui32\+Result\+Vector)}{PKAECCMultGenPtStart(uint32_t *pui32Scalar, tECCCurveInfo *ptCurve, uint32_t *pui32ResultVector)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+E\+C\+C\+Mult\+Gen\+Pt\+Start (
\begin{DoxyParamCaption}
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Scalar, }
\item[{{\bf t\+E\+C\+C\+Curve\+Info} $\ast$}]{pt\+Curve, }
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Result\+Vector}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga37519c82259a12764cb68cb265bc09c9}{}\label{group__pka__driver_ga37519c82259a12764cb68cb265bc09c9}
Starts the E\+CC Multiplication with Generator point.


\begin{DoxyParams}{Parameters}
{\em pui32\+Scalar} & is the to pointer to the buffer containing the scalar value. \\
\hline
{\em pt\+Curve} & is the pointer to the structure containing the curve info. \\
\hline
{\em pui32\+Result\+Vector} & is the pointer to the result vector location which will be set by this function.\\
\hline
\end{DoxyParams}
This function starts the ecc point multiplication operation of the scalar value with the well known generator point of the given curve.

\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if successful in starting the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy doing some other operation. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 1459 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+E\+C\+C\+Multiply\+Get\+Result@{P\+K\+A\+E\+C\+C\+Multiply\+Get\+Result}}
\index{P\+K\+A\+E\+C\+C\+Multiply\+Get\+Result@{P\+K\+A\+E\+C\+C\+Multiply\+Get\+Result}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+E\+C\+C\+Multiply\+Get\+Result(t\+E\+C\+Pt $\ast$pt\+Out\+Ec\+Pt, uint32\+\_\+t ui32\+Res\+Vector\+Loc)}{PKAECCMultiplyGetResult(tECPt *ptOutEcPt, uint32_t ui32ResVectorLoc)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+E\+C\+C\+Multiply\+Get\+Result (
\begin{DoxyParamCaption}
\item[{{\bf t\+E\+C\+Pt} $\ast$}]{pt\+Out\+Ec\+Pt, }
\item[{{\bf uint32\+\_\+t}}]{ui32\+Res\+Vector\+Loc}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga8ed171250f4b3a26e1f8268a41503450}{}\label{group__pka__driver_ga8ed171250f4b3a26e1f8268a41503450}
Gets the result of E\+CC Multiplication


\begin{DoxyParams}{Parameters}
{\em pt\+Out\+Ec\+Pt} & is the pointer to the structure where the resultant EC point will be stored. The callee is responsible to allocate the space for the ec point structure and the x and y co-\/ordinate as well. \\
\hline
{\em ui32\+Res\+Vector\+Loc} & is the address of the result location which was provided by the start function \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_ga99c8ab12e5a5fcba7f63ad0d2f9a98dd}{P\+K\+A\+E\+C\+C\+Multiply\+Start()}.
\end{DoxySeeAlso}
This function gets the result of ecc point multiplication operation on the ec point and the scalar value, previously started using the function \begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_ga99c8ab12e5a5fcba7f63ad0d2f9a98dd}{P\+K\+A\+E\+C\+C\+Multiply\+Start()}.
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if the operation is successful.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy performing the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+0} if the result is all zeroes.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+F\+A\+I\+L\+U\+RE} if the operation is not successful. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 1363 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+E\+C\+C\+Multiply\+Start@{P\+K\+A\+E\+C\+C\+Multiply\+Start}}
\index{P\+K\+A\+E\+C\+C\+Multiply\+Start@{P\+K\+A\+E\+C\+C\+Multiply\+Start}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+E\+C\+C\+Multiply\+Start(uint32\+\_\+t $\ast$pui32\+Scalar, t\+E\+C\+Pt $\ast$pt\+Ec\+Pt, t\+E\+C\+C\+Curve\+Info $\ast$pt\+Curve, uint32\+\_\+t $\ast$pui32\+Result\+Vector)}{PKAECCMultiplyStart(uint32_t *pui32Scalar, tECPt *ptEcPt, tECCCurveInfo *ptCurve, uint32_t *pui32ResultVector)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+E\+C\+C\+Multiply\+Start (
\begin{DoxyParamCaption}
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Scalar, }
\item[{{\bf t\+E\+C\+Pt} $\ast$}]{pt\+Ec\+Pt, }
\item[{{\bf t\+E\+C\+C\+Curve\+Info} $\ast$}]{pt\+Curve, }
\item[{{\bf uint32\+\_\+t} $\ast$}]{pui32\+Result\+Vector}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga99c8ab12e5a5fcba7f63ad0d2f9a98dd}{}\label{group__pka__driver_ga99c8ab12e5a5fcba7f63ad0d2f9a98dd}
Starts E\+CC Multiplication.


\begin{DoxyParams}{Parameters}
{\em pui32\+Scalar} & is pointer to the buffer containing the scalar value to be multiplied. \\
\hline
{\em pt\+Ec\+Pt} & is the pointer to the structure containing the elliptic curve point to be multiplied. The point should be on the given curve. \\
\hline
{\em pt\+Curve} & is the pointer to the structure containing the curve info. \\
\hline
{\em pui32\+Result\+Vector} & is the pointer to the result vector location which will be set by this function.\\
\hline
\end{DoxyParams}
This function starts the Elliptical curve cryptography (E\+CC) point multiplication operation on the EC point and the scalar value.

\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+S\+U\+C\+C\+E\+SS} if successful in starting the operation.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+I\+N\+P\+RG}, if the P\+KA hw module is busy doing some other operation. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 1185 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Enable\+Int@{P\+K\+A\+Enable\+Int}}
\index{P\+K\+A\+Enable\+Int@{P\+K\+A\+Enable\+Int}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Enable\+Int(void)}{PKAEnableInt(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} P\+K\+A\+Enable\+Int (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_gaed47ea15b15663675629b0e0388afede}{}\label{group__pka__driver_gaed47ea15b15663675629b0e0388afede}
Enables the P\+KA interrupt.

This function enables the P\+KA interrupt.

\begin{DoxyReturn}{Returns}
None. 
\end{DoxyReturn}


Definition at line 104 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Get\+Ops\+Status@{P\+K\+A\+Get\+Ops\+Status}}
\index{P\+K\+A\+Get\+Ops\+Status@{P\+K\+A\+Get\+Ops\+Status}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Get\+Ops\+Status(void)}{PKAGetOpsStatus(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf t\+P\+K\+A\+Status} P\+K\+A\+Get\+Ops\+Status (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga82d30b6e54d4e06c2fd871dbefbf90c5}{}\label{group__pka__driver_ga82d30b6e54d4e06c2fd871dbefbf90c5}
Provides the P\+KA operation status.

This function provides information on whether any P\+KA operation is in progress or not. This function allows to check the P\+KA operation status before starting any new P\+KA operation.

\begin{DoxyReturn}{Returns}
Returns\+:
\begin{DoxyItemize}
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+P\+RG} if the P\+KA operation is in progress.
\item {\bfseries P\+K\+A\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+O\+P\+E\+R\+A\+T\+I\+O\+N\+\_\+\+N\+O\+T\+\_\+\+I\+N\+P\+RG} if the P\+KA operation is not in progress. 
\end{DoxyItemize}
\end{DoxyReturn}


Definition at line 209 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Reg\+Int@{P\+K\+A\+Reg\+Int}}
\index{P\+K\+A\+Reg\+Int@{P\+K\+A\+Reg\+Int}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Reg\+Int(void($\ast$pfn\+Handler)(void))}{PKARegInt(void(*pfnHandler)(void))}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} P\+K\+A\+Reg\+Int (
\begin{DoxyParamCaption}
\item[{{\bf void}($\ast$)({\bf void})}]{pfn\+Handler}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga8e873132638c12c2ac9fca35a36013d6}{}\label{group__pka__driver_ga8e873132638c12c2ac9fca35a36013d6}
Registers an interrupt handler for P\+KA interrupt.


\begin{DoxyParams}{Parameters}
{\em pfn\+Handler} & is a pointer to the function to be called when the P\+KA interrupt occurs.\\
\hline
\end{DoxyParams}
This function does the actual registering of the interrupt handler. This will not enable the P\+KA interrupt in the interrupt controller, a call to the function \begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_gaed47ea15b15663675629b0e0388afede}{P\+K\+A\+Enable\+Int()} is needed to enable the P\+KA \hyperlink{_g_c_c_2_m_s_p430_f449_2port_8c_ae0992854bdba99f7b163894433c32aef}{interrupt}.

\hyperlink{group__interrupt__api_ga0a32aafea7f4904d2a64ee18b45f96c9}{Int\+Register()} for important information about registering \hyperlink{_g_c_c_2_m_s_p430_f449_2port_8c_ae0992854bdba99f7b163894433c32aef}{interrupt} handlers.
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
None. 
\end{DoxyReturn}


Definition at line 167 of file pka.\+c.

\index{Pka\+\_\+driver@{Pka\+\_\+driver}!P\+K\+A\+Un\+Reg\+Int@{P\+K\+A\+Un\+Reg\+Int}}
\index{P\+K\+A\+Un\+Reg\+Int@{P\+K\+A\+Un\+Reg\+Int}!Pka\+\_\+driver@{Pka\+\_\+driver}}
\subsubsection[{\texorpdfstring{P\+K\+A\+Un\+Reg\+Int(void)}{PKAUnRegInt(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} P\+K\+A\+Un\+Reg\+Int (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{group__pka__driver_ga2d21625a6c77aee8721066476a68275d}{}\label{group__pka__driver_ga2d21625a6c77aee8721066476a68275d}
Unregisters an interrupt handler for the P\+KA interrupt.

This function deregisters the interrupt service routine. This function will not disable the interrupt and an explicit call to \begin{DoxySeeAlso}{See also}
\hyperlink{group__pka__driver_ga332c572585f555dc982817a355284f70}{P\+K\+A\+Disable\+Int()} is needed.
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
None. 
\end{DoxyReturn}


Definition at line 187 of file pka.\+c.

